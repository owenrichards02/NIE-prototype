<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: react_api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: react_api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { HTMLByAttribute, HTMLByAttributeValue, HTMLByTag, HTMLByTagValueContains } from './fragment.js';
import { Binary, ObjectId } from 'bson';

import { realm_addNewItem, realm_deleteDocument, realm_deleteFragment, realm_getAllAnnotations, realm_getAllAnnotations_fromSpecificFragment, realm_getAllDocuments, realm_getAllFloors, realm_getAllFragments, realm_getAllFragments_fromSpecificDoc, realm_getItem, realm_searchByTagList_AND, realm_searchByTagList_OR, realm_tagItem, realm_updateItem } from './realm_CRUD.js';
import { parse, stringify } from 'flatted';



/** 
 * Finds all fragments currently linked to this document in the fragments container
 * Returns an object containing lists of both fragment types: HTML and Binary.
 *
 * @export
 * @param {ObjectId} doc_id
 * @return {Object.&lt;string, Array&lt;String|BinaryData>>} 
 */
export async function fragments_search_by_linked_document(doc_id){
    const rawFragList = await realm_getAllFragments_fromSpecificDoc(doc_id)
    let htmlfragList = []
    let binaryfragList = []

    for (const frag of rawFragList){
        if (frag.html != null){
            htmlfragList.push(frag)
        }else{
            binaryfragList.push(frag)
        }
    }

    const fragments = {
        binaryDataFrags : binaryfragList,
        htmlfragList : htmlfragList
    }

    return fragments
}

//dont use this directly
async function document_add_data(data, filepath, type, tags=[]) { 

    const filename = filepath.split("/").at(-1)

    const newdoc = {
        name: filename,
        data: data,
        html: null,
        type: type,
        tags: tags
    }

    const id = await realm_addNewItem("documents", newdoc)

    return id
}

/**
 * Adds a new document to the collection, using the provided html string as the document's content. Takes a filepath to use as the document name, as well as a type to use for images. Returns the ObjectID for the new document.
 * 
 *
 * @export
 * @param {string} html
 * @param {string} filepath
 * @param {string} type
 * @param {Array&lt;string>} [tags=[]]
 * @return {ObjectId} id
 */
export async function document_add_html(html, filepath, type, tags=[]) {

    const filename = filepath.split("/").at(-1)

    const newdoc = {
        name: filename,
        data: null,
        html: html,
        type: type,
        tags: tags
    }

    const id = await realm_addNewItem("documents", newdoc)

    return id
}

/**
 * Stores an HTML based fragment in the fragments container. Requires a documentID.
 * Returns the id mongodb assigned to the fragment
 *
 * @export
 * @param {string} html
 * @param {ObjectId} docid
 * @param {string} [fragName="testFragment"]
 * @param {string} type
 * @param {Array&lt;string>} [tags=[]]
 * @return {ObjectId} 
 */
export async function fragment_add_html(html, docid, fragName="testFragment", type, coords = null, tags=[]) {

    const newfrag = {
        name: fragName,
        docid: docid,
        html: html  ,
        data: null,
        type: type,
        coords: coords,
        tags: tags
    }

    const id = await realm_addNewItem("fragments", newfrag)

    return id
}


/**
 * Stores an non-HTML based fragment in the fragments container, as a binary object.
 * Requires a documentID.
 * Returns the id mongodb assigned to the fragment
 *
 * @export
 * @param {BinaryData} data
 * @param {ObjectId} docid
 * @param {string} [fragName="testFragment"]
 * @return {ObjectId} 
 */
export async function fragment_add_data(data, docid, fragName="testFragment", type, tags=[]) { 

    const newfrag = {
        name: fragName,
        docid: docid,
        html: null,
        data: data,
        type: type,
        tags: tags
    }

    const id = await realm_addNewItem("fragments", newfrag)

    return id
}


/**
 * Fetches a fragment from the fragments container using the fragmentID.
 * Returns the object
 *
 * @export
 * @param {ObjectId} id
 * @return {BinaryData|string} 
 */
export async function fragment_find(id) { 

    const newfrag = await realm_getItem("fragments", id)
    return newfrag
     
}

/**
 * Fetches a document from the documents container using the documentID.
 * Returns the object
 *
 * @export
 * @param {ObjectId} id
 * @return {object} 
 */
export async function document_find(id) { 

    const newDoc = await realm_getItem("documents", id)
    return newDoc
}

/**
 * Fetches a annotation from the annotations container using the annotationID.
 * Returns the object
 *
 * @export
 * @param {ObjectId} id
 * @return {object} 
 */
export async function annotation_find(id) { 

    const newDoc = await realm_getItem("annotations", id)
    return newDoc
}




/**
 * Deletes a document from the documents container using a documentID. Returns a DeleteResult for confirmation.
 * WILL ALSO DELETE ALL FRAGMENTS LINKED TO THE DOC.
 *
 * @export
 * @param {ObjectId} id
 * @return {DeleteResult} 
 */
export async function document_delete(id){return await realm_deleteDocument(id)}


/**
 * Deletes a fragment from the fragments container using a fragmentID. Returns a DeleteResult for confirmation.
 *
 * @export
 * @param {ObjectId} id
 * @return {DeleteResult} 
 */
export async function fragment_delete(id){return await realm_deleteFragment(id)}


/**
 * Searches through a registered html document for html sections with matching attributes. Returns a list of the tag sections that match
 *
 * @export
 * @param {ObjectId} docid
 * @param {String} attribute
 * @return {Array&lt;String>} 
 */
export async function document_searchContentsFor_HTMLattribute(docid, attribute){

    let matches = []
    const doc = await document_find(docid)
    if (doc.html!=null){
        matches = await HTMLByAttribute(doc.html, attribute)
    }else{
        console.error("File has no HTML content: " + docid)
    }

    return matches

}

/**
 * Searches through a registered html document for html sections with matching attribute-value pairs. Returns a list of the tag sections that match
 *
 * @export
 * @param {ObjectId} docid
 * @param {String} attribute
 * @param {String} value
 * @return {Array&lt;String>} 
 */
export async function document_searchContentsFor_HTMLattributeValue(docid, attribute, value){

    let matches = []
    const doc = await document_find(docid)

    if (doc.html!=null){
        matches = await HTMLByAttributeValue(doc, attribute, value)
    }else{
        console.error("File has no HTML content: " + docid)
    }

    return matches
    
}

/**
 *
 * Searches through a registered html document for html sections with matching tag-value pairs. Returns a list of the tag sections that match.
 * Provides the option to specify tag class, for greater refinement.
 * 
 * Leaving the value field null means all matching tags, regardless of tag-value will be returned.
 *
 * @export
 * @param {ObjectId} docid
 * @param {string} tag
 * @param {string} value
 * @param {string} [t_class=null]
 * @return {*} 
 */
export async function document_searchContentsFor_HTMLTagValue(docid, tag, value=null, t_class=null){
    let matches = []
    const doc = await document_find(docid)

    if (doc.html!=null){
        if (value != null){
            matches = await HTMLByTagValueContains(doc, tag, value, t_class)
        }else{
            matches = await HTMLByTag(doc,tag,t_class)
        }
    }else{
        console.error("File has no HTML content: " + docid)
    }

    return matches
}


/**
 * Adds a tag (string) to an existing document. Returns 0 if successful, -1 otherwise.
 *
 * @export
 * @param {ObjectId} docid
 * @param {string} tag
 * @return {number} 
 */
export async function document_addTag(docid, tag){const res = await realm_tagItem("documents", docid, tag); return res}


/**
 * Adds a tag (string) to an existing fragment. Returns 0 if successful, -1 otherwise.
 *
 * @export
 * @param {ObjectId} fragid
 * @param {string} tag
 * @return {number} 
 */
export async function fragment_addTag(fragid, tag){const res = await realm_tagItem("fragments", fragid, tag); return res}


/**
 * Adds a tag (string) to an existing annotation. Returns 0 if successful, -1 otherwise.
 *
 * @export
 * @param {ObjectId} fragid
 * @param {string} tag
 * @return {number} 
 */
export async function annotation_addTag(fragid, tag){const res = await realm_tagItem("annotations", fragid, tag); return res}


/**
 * Retrieves all documents tagged with AT LEAST ONE of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function document_searchByTagsList_OR(tagList){
    const docs = await realm_searchByTagList_OR("documents", tagList)
    return docs
}

/**
 * Retrieves all documents tagged with ALL of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function documents_searchByTagsList_AND(tagList){
    const docs = await realm_searchByTagList_AND("documents", tagList)
    return docs
}

/**
 * Retrieves all fragments tagged with AT LEAST ONE of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function fragment_searchByTagsList_OR(tagList){
    const frags = await realm_searchByTagList_OR("fragments", tagList)
    return frags
}


/**
 * Retrieves all fragments tagged with ALL of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function fragment_searchByTagsList_AND(tagList){
    const frags = await realm_searchByTagList_AND("fragments", tagList)
    return frags
}

/**
 * Retrieves all annotations tagged with AT LEAST ONE of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function annotation_searchByTagList_OR(tagList){
    const frags = await realm_searchByTagList_OR("annotations", tagList)
    return frags
}


/**
 * Retrieves all annotations tagged with ALL of the tags in tagList.
 *
 * @export
 * @param {Array&lt;string>} tagList
 * @return {Array&lt;object>} docs
 */
export async function annotation_searchByTagList_AND(tagList){
    const frags = await realm_searchByTagList_AND("annotations", tagList)
    return frags
}


/**
 *  Creates an annotation from html content and links it to the available fragments. Options for naming and tagging the annotation are included.
 * 
 *
 * @export
 * @param {string} htmlContent
 * @param {Array&lt;ObjectId>} fragmentIDList
 * @param {Array&lt;string>} [tags=[]]
 * @param {string} [annotationName="New annotation"]
 * @return {ObjectId} insertedID 
 */
export async function annotation_create(htmlContent, fragmentIDList, color, tags=[], annotationName="New annotation"){
    const newAnnot = {
        name: annotationName,
        content: htmlContent,
        color: color,
        linkedFragments: fragmentIDList,
        tags: tags,
    }

    const insertedId = await realm_addNewItem("annotations", newAnnot)
    return insertedId
}


/**
 *  Gets all the annotations linked to a specific fragment.
 *
 * @export
 * @param {ObjectId} fragmentID
 * @return {Array&lt;object>} 
 */
export async function annotation_search_by_linked_fragmentID(fragmentID){
    const annotations = await realm_getAllAnnotations_fromSpecificFragment(fragmentID)
    return annotations
}


/**
 * Finds all HTML tags containing text and returns them, in a list of html tags
 *
 * @export
 * @param {string} html
 * @return {Array&lt;string>} 
 */
export function HTML_2_Textual_Fragments(html){
    return extractAllTextualFragments(html)
}


/**
 * Searches html representations of the .xlsx survey format, returning all questions and response pairs, denoted by the .qna class.
 * Returns a list of html strings
 *
 * @export
 * @param {string} html
 * @return {Array&lt;string>} 
 */
export function HTML_2_Dialogue_List(html){
    return extractAllInterviewDialogueSections(html)
}


/**
 * Searches html representations of the known .txt transcript otter.ai format, returning all dialogue sections as a list, as dented by the .dialogue class.
 *
 * @export
 * @param {string} html
 * @return {Array&lt;string>} 
 */
export function HTML_2_QnA_List(html){
    return extractAllSurveyQuestions(html)
}



/**
 * Get HTML tags containing each answer to a specific survey question. Provide the document ID of the survey, and the name of the question you would like to query.
 * 
 *
 * @export
 * @param {ObjectId} doc_id
 * @param {string} questionName
 * @return {Array&lt;string>} questionList [HTML String]
 */
export async function survey_AnswersToASpecificQuestion(doc_id, questionName){
    const doc = await document_find(doc_id)

    let questionList = []

    if (doc.type != "survey"){
        console.error("Wrong doc type! It must be a survey.")
    }else{
        const html = await doc.html

        const qnas = await HTMLByTagValueContains(html,"li",questionName,"qna" )

        for (const qna of qnas){
            const a = await HTMLByTag(qna, "p", "answer")
            questionList.push(a[0])
        }
        //console.log(qnas)

    }

    return questionList

}

/**
 * Get HTML tags containing each dialogue section from a specific speaker. Provide the document ID of the transcript, and the name of the speaker you would like to query.
 * 
 *
 * @export
 * @param {ObjectId} doc_id
 * @param {string} speakerName
 * @return {Array&lt;string>} questionList [HTML String]
 */
export async function transcript_DialogueFromASpecificSpeaker(doc_id, speakerName){
    const doc = await document_find(doc_id)

    let dialogueList = []

    if (doc.type != "transcript"){
        console.error("Wrong doc type! It must be a transcript. : " + doc.type)
    }else{
        const html = await doc.html

        const sections = await HTMLByTagValueContains(html,"li",speakerName,"dialogue")

        for (const sect of sections){
            const dialogue = await HTMLByTag(sect, "p", "speech")
            dialogueList.push(dialogue[0])
        }
    }

    return dialogueList

}


/**
 * Saves a new virtual floor. Takes an object containing the a2c and f2c object for the new floor, and returns the ID of the new floor.
 * 
 *
 * @export
 * @param {object} floor_object
 * @param {string} name
 * @return {ObjectId} insertedID 
 */
export async function floor_save(floor_object, name){

    //removes any circular references that stop JSON parsing from working when saving the floor.
    let flat_floor = stringify(floor_object)

    let realmObj = {
        floor: flat_floor,
        name: name
    }

    const id = await realm_addNewItem('virtualFloors', realmObj)

    return id
}

/**
 * Resaves an existing virtual floor. Takes an updated object containing the a2c and f2c object for the new floor, and returns the ID of the new floor.
 * 
 *
 * @export
 * @param {object} floor_object
 * @param {string} name
 * @return {ObjectId} insertedID 
 */
export async function floor_update(floor_object, floor_id, name){

    //removes any circular references that stop JSON parsing from working when saving the floor.
    let flat_floor = stringify(floor_object)

    let realmObj = {
        floor: flat_floor,
        name: name
    }

    const id = await realm_updateItem('virtualFloors', floor_id, realmObj)

    return id
}

/**
 * Fetches all documents from the documents container
 * Returns a list of document objects
 *
 * @export
 * @return {Array&lt;object>} 
 */
export async function documents_findAll(){
    const docs = await realm_getAllDocuments()
    return docs
}

/**
 * Fetches all annotations from the annotations container
 * Returns a list of annotation objects
 *
 * @export
 * @return {Array&lt;object>} 
 */
export async function annotations_findAll(){
    const annots = await realm_getAllAnnotations()
    return annots
}

/**
 * Fetches all fragments from the fragments container
 * Returns a list of fragment objects
 *
 * @export
 * @return {Array&lt;object>} 
 */
export async function fragments_findAll(){
    const fragments = await realm_getAllFragments()
    return fragments
}

/**
 * Fetches all floors from the floors container
 * Returns a list of floor objects
 *
 * @export
 * @return {Array&lt;object>} 
 */
export async function floors_findAll(){
    const vfs = await realm_getAllFloors()

    //undo flatten serialisation
    for (const vf of vfs){
        let flat_floor = parse(vf.floor)
        vf.floor = flat_floor
    }

    return vfs
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#HTML_2_Dialogue_List">HTML_2_Dialogue_List</a></li><li><a href="global.html#HTML_2_QnA_List">HTML_2_QnA_List</a></li><li><a href="global.html#HTML_2_Textual_Fragments">HTML_2_Textual_Fragments</a></li><li><a href="global.html#annotation_addTag">annotation_addTag</a></li><li><a href="global.html#annotation_create">annotation_create</a></li><li><a href="global.html#annotation_find">annotation_find</a></li><li><a href="global.html#annotation_searchByTagList_AND">annotation_searchByTagList_AND</a></li><li><a href="global.html#annotation_searchByTagList_OR">annotation_searchByTagList_OR</a></li><li><a href="global.html#annotation_search_by_linked_fragmentID">annotation_search_by_linked_fragmentID</a></li><li><a href="global.html#annotations_findAll">annotations_findAll</a></li><li><a href="global.html#document_addTag">document_addTag</a></li><li><a href="global.html#document_add_html">document_add_html</a></li><li><a href="global.html#document_delete">document_delete</a></li><li><a href="global.html#document_find">document_find</a></li><li><a href="global.html#document_searchByTagsList_OR">document_searchByTagsList_OR</a></li><li><a href="global.html#document_searchContentsFor_HTMLTagValue">document_searchContentsFor_HTMLTagValue</a></li><li><a href="global.html#document_searchContentsFor_HTMLattribute">document_searchContentsFor_HTMLattribute</a></li><li><a href="global.html#document_searchContentsFor_HTMLattributeValue">document_searchContentsFor_HTMLattributeValue</a></li><li><a href="global.html#documents_findAll">documents_findAll</a></li><li><a href="global.html#documents_searchByTagsList_AND">documents_searchByTagsList_AND</a></li><li><a href="global.html#floor_save">floor_save</a></li><li><a href="global.html#floor_update">floor_update</a></li><li><a href="global.html#floors_findAll">floors_findAll</a></li><li><a href="global.html#fragment_addTag">fragment_addTag</a></li><li><a href="global.html#fragment_add_data">fragment_add_data</a></li><li><a href="global.html#fragment_add_html">fragment_add_html</a></li><li><a href="global.html#fragment_delete">fragment_delete</a></li><li><a href="global.html#fragment_find">fragment_find</a></li><li><a href="global.html#fragment_searchByTagsList_AND">fragment_searchByTagsList_AND</a></li><li><a href="global.html#fragment_searchByTagsList_OR">fragment_searchByTagsList_OR</a></li><li><a href="global.html#fragments_findAll">fragments_findAll</a></li><li><a href="global.html#fragments_search_by_linked_document">fragments_search_by_linked_document</a></li><li><a href="global.html#survey_AnswersToASpecificQuestion">survey_AnswersToASpecificQuestion</a></li><li><a href="global.html#transcript_DialogueFromASpecificSpeaker">transcript_DialogueFromASpecificSpeaker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Wed Aug 28 2024 17:22:59 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
